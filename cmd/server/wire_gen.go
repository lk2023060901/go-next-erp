// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"fmt"
	"github.com/go-kratos/kratos/v2"
	"github.com/go-kratos/kratos/v2/log"
	"github.com/lk2023060901/go-next-erp/internal/adapter"
	"github.com/lk2023060901/go-next-erp/internal/auth/authentication"
	"github.com/lk2023060901/go-next-erp/internal/auth/authentication/jwt"
	"github.com/lk2023060901/go-next-erp/internal/auth/authorization"
	"github.com/lk2023060901/go-next-erp/internal/auth/repository"
	"github.com/lk2023060901/go-next-erp/internal/conf"
	"github.com/lk2023060901/go-next-erp/internal/server"
	"github.com/lk2023060901/go-next-erp/pkg/cache"
	"github.com/lk2023060901/go-next-erp/pkg/database"
	"strings"
	"time"
)

// Injectors from wire.go:

// wireApp 通过 Wire 自动生成依赖注入代码
func wireApp(config *conf.Config, logger log.Logger) (*kratos.App, func(), error) {
	db, cleanup, err := provideDatabase(config)
	if err != nil {
		return nil, nil, err
	}
	redis, cleanup2, err := provideCache(config)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	userRepository := repository.NewUserRepository(db, redis)
	sessionRepository := repository.NewSessionRepository(db, redis)
	auditLogRepository := repository.NewAuditLogRepository(db)
	jwtConfig := provideJWTConfig(config)
	service := authentication.NewService(userRepository, sessionRepository, auditLogRepository, jwtConfig)
	authAdapter := adapter.NewAuthAdapter(service, userRepository)
	roleRepository := repository.NewRoleRepository(db, redis)
	permissionRepository := repository.NewPermissionRepository(db, redis)
	policyRepository := repository.NewPolicyRepository(db, redis)
	relationRepository := repository.NewRelationRepository(db, redis)
	authorizationService := authorization.NewService(roleRepository, permissionRepository, policyRepository, userRepository, relationRepository, auditLogRepository, redis)
	userAdapter := adapter.NewUserAdapter(userRepository, roleRepository, authorizationService)
	roleAdapter := adapter.NewRoleAdapter(roleRepository, permissionRepository)
	httpServer := server.NewHTTPServer(authAdapter, userAdapter, roleAdapter, logger)
	grpcServer := server.NewGRPCServer(authAdapter, userAdapter, roleAdapter, logger)
	app := newApp(logger, httpServer, grpcServer)
	return app, func() {
		cleanup2()
		cleanup()
	}, nil
}

// wire.go:

// provideDatabase 提供数据库连接
func provideDatabase(c *conf.Config) (*database.DB, func(), error) {
	ctx := context.Background()

	parts := strings.TrimPrefix(c.Database.Master, "postgres://")

	var dbCfg *database.Config
	if userPass, hostInfo, found := strings.Cut(parts, "@"); found {
		user, pass, _ := strings.Cut(userPass, ":")
		hostPort, dbParams, _ := strings.Cut(hostInfo, "/")
		host, portStr, _ := strings.Cut(hostPort, ":")
		dbName, _, _ := strings.Cut(dbParams, "?")

		port := 5432
		fmt.Sscanf(portStr, "%d", &port)

		dbCfg = &database.Config{
			Host:     host,
			Port:     port,
			Database: dbName,
			Username: user,
			Password: pass,
			SSLMode:  "disable",
			MaxConns: int32(c.Database.MaxOpenConns),
			MinConns: int32(c.Database.MaxIdleConns),
		}
	} else {
		return nil, nil, fmt.Errorf("invalid database connection string")
	}

	opts := []database.Option{
		func(cfg *database.Config) {
			*cfg = *dbCfg
		},
	}

	db, err := database.New(ctx, opts...)
	if err != nil {
		return nil, nil, err
	}

	cleanup := func() {
		db.Close()
	}

	return db, cleanup, nil
}

// provideCache 提供缓存客户端
func provideCache(c *conf.Config) (*cache.Redis, func(), error) {
	ctx := context.Background()

	host, portStr, _ := strings.Cut(c.Redis.Addr, ":")
	port := 6379
	fmt.Sscanf(portStr, "%d", &port)

	cacheCfg := &cache.Config{
		Host:     host,
		Port:     port,
		Password: c.Redis.Password,
		DB:       c.Redis.DB,
	}

	opts := []cache.Option{
		func(cfg *cache.Config) {
			*cfg = *cacheCfg
		},
	}

	redis, err := cache.New(ctx, opts...)
	if err != nil {
		return nil, nil, err
	}

	cleanup := func() {
		redis.Close()
	}

	return redis, cleanup, nil
}

// provideJWTConfig 提供 JWT 配置
func provideJWTConfig(c *conf.Config) *jwt.Config {
	return &jwt.Config{
		SecretKey:       c.JWT.Secret,
		AccessTokenTTL:  time.Duration(c.JWT.AccessExpire) * time.Second,
		RefreshTokenTTL: time.Duration(c.JWT.RefreshExpire) * time.Second,
		Issuer:          "go-next-erp",
	}
}
