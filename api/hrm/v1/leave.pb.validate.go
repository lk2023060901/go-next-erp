// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/hrm/v1/leave.proto

package hrmv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ApprovalNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ApprovalNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApprovalNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ApprovalNodeMultiError, or
// nil if none found.
func (m *ApprovalNode) ValidateAll() error {
	return m.validate(true)
}

func (m *ApprovalNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Level

	// no validation rules for ApproverType

	// no validation rules for ApproverId

	// no validation rules for Required

	if len(errors) > 0 {
		return ApprovalNodeMultiError(errors)
	}

	return nil
}

// ApprovalNodeMultiError is an error wrapping multiple validation errors
// returned by ApprovalNode.ValidateAll() if the designated constraints aren't met.
type ApprovalNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApprovalNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApprovalNodeMultiError) AllErrors() []error { return m }

// ApprovalNodeValidationError is the validation error returned by
// ApprovalNode.Validate if the designated constraints aren't met.
type ApprovalNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApprovalNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApprovalNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApprovalNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApprovalNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApprovalNodeValidationError) ErrorName() string { return "ApprovalNodeValidationError" }

// Error satisfies the builtin error interface
func (e ApprovalNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApprovalNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApprovalNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApprovalNodeValidationError{}

// Validate checks the field values on DurationRule with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DurationRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DurationRule with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DurationRuleMultiError, or
// nil if none found.
func (m *DurationRule) ValidateAll() error {
	return m.validate(true)
}

func (m *DurationRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MinDuration

	// no validation rules for MaxDuration

	for idx, item := range m.GetApprovalChain() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DurationRuleValidationError{
						field:  fmt.Sprintf("ApprovalChain[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DurationRuleValidationError{
						field:  fmt.Sprintf("ApprovalChain[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DurationRuleValidationError{
					field:  fmt.Sprintf("ApprovalChain[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DurationRuleMultiError(errors)
	}

	return nil
}

// DurationRuleMultiError is an error wrapping multiple validation errors
// returned by DurationRule.ValidateAll() if the designated constraints aren't met.
type DurationRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DurationRuleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DurationRuleMultiError) AllErrors() []error { return m }

// DurationRuleValidationError is the validation error returned by
// DurationRule.Validate if the designated constraints aren't met.
type DurationRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DurationRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DurationRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DurationRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DurationRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DurationRuleValidationError) ErrorName() string { return "DurationRuleValidationError" }

// Error satisfies the builtin error interface
func (e DurationRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDurationRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DurationRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DurationRuleValidationError{}

// Validate checks the field values on ApprovalRules with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ApprovalRules) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApprovalRules with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ApprovalRulesMultiError, or
// nil if none found.
func (m *ApprovalRules) ValidateAll() error {
	return m.validate(true)
}

func (m *ApprovalRules) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDefaultChain() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApprovalRulesValidationError{
						field:  fmt.Sprintf("DefaultChain[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApprovalRulesValidationError{
						field:  fmt.Sprintf("DefaultChain[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApprovalRulesValidationError{
					field:  fmt.Sprintf("DefaultChain[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDurationRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApprovalRulesValidationError{
						field:  fmt.Sprintf("DurationRules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApprovalRulesValidationError{
						field:  fmt.Sprintf("DurationRules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApprovalRulesValidationError{
					field:  fmt.Sprintf("DurationRules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ApprovalRulesMultiError(errors)
	}

	return nil
}

// ApprovalRulesMultiError is an error wrapping multiple validation errors
// returned by ApprovalRules.ValidateAll() if the designated constraints
// aren't met.
type ApprovalRulesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApprovalRulesMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApprovalRulesMultiError) AllErrors() []error { return m }

// ApprovalRulesValidationError is the validation error returned by
// ApprovalRules.Validate if the designated constraints aren't met.
type ApprovalRulesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApprovalRulesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApprovalRulesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApprovalRulesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApprovalRulesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApprovalRulesValidationError) ErrorName() string { return "ApprovalRulesValidationError" }

// Error satisfies the builtin error interface
func (e ApprovalRulesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApprovalRules.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApprovalRulesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApprovalRulesValidationError{}

// Validate checks the field values on LeaveTypeResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LeaveTypeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeaveTypeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LeaveTypeResponseMultiError, or nil if none found.
func (m *LeaveTypeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LeaveTypeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TenantId

	// no validation rules for Code

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for IsPaid

	// no validation rules for RequiresApproval

	// no validation rules for RequiresProof

	// no validation rules for DeductQuota

	// no validation rules for Unit

	// no validation rules for MinDuration

	// no validation rules for MaxDuration

	// no validation rules for AdvanceDays

	if all {
		switch v := interface{}(m.GetApprovalRules()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeaveTypeResponseValidationError{
					field:  "ApprovalRules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeaveTypeResponseValidationError{
					field:  "ApprovalRules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApprovalRules()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeaveTypeResponseValidationError{
				field:  "ApprovalRules",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Color

	// no validation rules for IsActive

	// no validation rules for Sort

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeaveTypeResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeaveTypeResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeaveTypeResponseValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LeaveTypeResponseMultiError(errors)
	}

	return nil
}

// LeaveTypeResponseMultiError is an error wrapping multiple validation errors
// returned by LeaveTypeResponse.ValidateAll() if the designated constraints
// aren't met.
type LeaveTypeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeaveTypeResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeaveTypeResponseMultiError) AllErrors() []error { return m }

// LeaveTypeResponseValidationError is the validation error returned by
// LeaveTypeResponse.Validate if the designated constraints aren't met.
type LeaveTypeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeaveTypeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeaveTypeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeaveTypeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeaveTypeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeaveTypeResponseValidationError) ErrorName() string {
	return "LeaveTypeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e LeaveTypeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeaveTypeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeaveTypeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeaveTypeResponseValidationError{}

// Validate checks the field values on LeaveRequestResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LeaveRequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeaveRequestResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LeaveRequestResponseMultiError, or nil if none found.
func (m *LeaveRequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LeaveRequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TenantId

	// no validation rules for EmployeeId

	// no validation rules for EmployeeName

	// no validation rules for DepartmentId

	// no validation rules for LeaveTypeId

	// no validation rules for LeaveTypeName

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeaveRequestResponseValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeaveRequestResponseValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeaveRequestResponseValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeaveRequestResponseValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeaveRequestResponseValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeaveRequestResponseValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Duration

	// no validation rules for Unit

	// no validation rules for Reason

	// no validation rules for Status

	// no validation rules for CurrentApproverId

	if all {
		switch v := interface{}(m.GetSubmittedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeaveRequestResponseValidationError{
					field:  "SubmittedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeaveRequestResponseValidationError{
					field:  "SubmittedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubmittedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeaveRequestResponseValidationError{
				field:  "SubmittedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeaveRequestResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeaveRequestResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeaveRequestResponseValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LeaveRequestResponseMultiError(errors)
	}

	return nil
}

// LeaveRequestResponseMultiError is an error wrapping multiple validation
// errors returned by LeaveRequestResponse.ValidateAll() if the designated
// constraints aren't met.
type LeaveRequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeaveRequestResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeaveRequestResponseMultiError) AllErrors() []error { return m }

// LeaveRequestResponseValidationError is the validation error returned by
// LeaveRequestResponse.Validate if the designated constraints aren't met.
type LeaveRequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeaveRequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeaveRequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeaveRequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeaveRequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeaveRequestResponseValidationError) ErrorName() string {
	return "LeaveRequestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e LeaveRequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeaveRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeaveRequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeaveRequestResponseValidationError{}

// Validate checks the field values on LeaveRequestDetailResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LeaveRequestDetailResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeaveRequestDetailResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LeaveRequestDetailResponseMultiError, or nil if none found.
func (m *LeaveRequestDetailResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LeaveRequestDetailResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeaveRequestDetailResponseValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeaveRequestDetailResponseValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeaveRequestDetailResponseValidationError{
				field:  "Request",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetApprovals() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LeaveRequestDetailResponseValidationError{
						field:  fmt.Sprintf("Approvals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LeaveRequestDetailResponseValidationError{
						field:  fmt.Sprintf("Approvals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LeaveRequestDetailResponseValidationError{
					field:  fmt.Sprintf("Approvals[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LeaveRequestDetailResponseMultiError(errors)
	}

	return nil
}

// LeaveRequestDetailResponseMultiError is an error wrapping multiple
// validation errors returned by LeaveRequestDetailResponse.ValidateAll() if
// the designated constraints aren't met.
type LeaveRequestDetailResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeaveRequestDetailResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeaveRequestDetailResponseMultiError) AllErrors() []error { return m }

// LeaveRequestDetailResponseValidationError is the validation error returned
// by LeaveRequestDetailResponse.Validate if the designated constraints aren't met.
type LeaveRequestDetailResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeaveRequestDetailResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeaveRequestDetailResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeaveRequestDetailResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeaveRequestDetailResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeaveRequestDetailResponseValidationError) ErrorName() string {
	return "LeaveRequestDetailResponseValidationError"
}

// Error satisfies the builtin error interface
func (e LeaveRequestDetailResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeaveRequestDetailResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeaveRequestDetailResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeaveRequestDetailResponseValidationError{}

// Validate checks the field values on ApprovalResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ApprovalResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApprovalResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApprovalResponseMultiError, or nil if none found.
func (m *ApprovalResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ApprovalResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for LeaveRequestId

	// no validation rules for ApproverId

	// no validation rules for ApproverName

	// no validation rules for Level

	// no validation rules for Status

	// no validation rules for Action

	// no validation rules for Comment

	if all {
		switch v := interface{}(m.GetApprovedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApprovalResponseValidationError{
					field:  "ApprovedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApprovalResponseValidationError{
					field:  "ApprovedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApprovedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApprovalResponseValidationError{
				field:  "ApprovedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApprovalResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApprovalResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApprovalResponseValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ApprovalResponseMultiError(errors)
	}

	return nil
}

// ApprovalResponseMultiError is an error wrapping multiple validation errors
// returned by ApprovalResponse.ValidateAll() if the designated constraints
// aren't met.
type ApprovalResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApprovalResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApprovalResponseMultiError) AllErrors() []error { return m }

// ApprovalResponseValidationError is the validation error returned by
// ApprovalResponse.Validate if the designated constraints aren't met.
type ApprovalResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApprovalResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApprovalResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApprovalResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApprovalResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApprovalResponseValidationError) ErrorName() string { return "ApprovalResponseValidationError" }

// Error satisfies the builtin error interface
func (e ApprovalResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApprovalResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApprovalResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApprovalResponseValidationError{}

// Validate checks the field values on QuotaResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QuotaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QuotaResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QuotaResponseMultiError, or
// nil if none found.
func (m *QuotaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QuotaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for EmployeeId

	// no validation rules for LeaveTypeId

	// no validation rules for LeaveTypeName

	// no validation rules for LeaveTypeCode

	// no validation rules for Unit

	// no validation rules for Color

	// no validation rules for Year

	// no validation rules for TotalQuota

	// no validation rules for UsedQuota

	// no validation rules for PendingQuota

	// no validation rules for RemainingQuota

	if all {
		switch v := interface{}(m.GetExpiredAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuotaResponseValidationError{
					field:  "ExpiredAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuotaResponseValidationError{
					field:  "ExpiredAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiredAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuotaResponseValidationError{
				field:  "ExpiredAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QuotaResponseMultiError(errors)
	}

	return nil
}

// QuotaResponseMultiError is an error wrapping multiple validation errors
// returned by QuotaResponse.ValidateAll() if the designated constraints
// aren't met.
type QuotaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuotaResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuotaResponseMultiError) AllErrors() []error { return m }

// QuotaResponseValidationError is the validation error returned by
// QuotaResponse.Validate if the designated constraints aren't met.
type QuotaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuotaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuotaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuotaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuotaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuotaResponseValidationError) ErrorName() string { return "QuotaResponseValidationError" }

// Error satisfies the builtin error interface
func (e QuotaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuotaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuotaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuotaResponseValidationError{}

// Validate checks the field values on CreateLeaveTypeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateLeaveTypeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateLeaveTypeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateLeaveTypeRequestMultiError, or nil if none found.
func (m *CreateLeaveTypeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLeaveTypeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TenantId

	// no validation rules for Code

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for IsPaid

	// no validation rules for RequiresApproval

	// no validation rules for RequiresProof

	// no validation rules for DeductQuota

	// no validation rules for Unit

	// no validation rules for MinDuration

	// no validation rules for MaxDuration

	// no validation rules for AdvanceDays

	if all {
		switch v := interface{}(m.GetApprovalRules()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateLeaveTypeRequestValidationError{
					field:  "ApprovalRules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateLeaveTypeRequestValidationError{
					field:  "ApprovalRules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApprovalRules()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateLeaveTypeRequestValidationError{
				field:  "ApprovalRules",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Color

	// no validation rules for Sort

	if len(errors) > 0 {
		return CreateLeaveTypeRequestMultiError(errors)
	}

	return nil
}

// CreateLeaveTypeRequestMultiError is an error wrapping multiple validation
// errors returned by CreateLeaveTypeRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateLeaveTypeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLeaveTypeRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLeaveTypeRequestMultiError) AllErrors() []error { return m }

// CreateLeaveTypeRequestValidationError is the validation error returned by
// CreateLeaveTypeRequest.Validate if the designated constraints aren't met.
type CreateLeaveTypeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLeaveTypeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLeaveTypeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLeaveTypeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLeaveTypeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLeaveTypeRequestValidationError) ErrorName() string {
	return "CreateLeaveTypeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLeaveTypeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLeaveTypeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLeaveTypeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLeaveTypeRequestValidationError{}

// Validate checks the field values on UpdateLeaveTypeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateLeaveTypeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateLeaveTypeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateLeaveTypeRequestMultiError, or nil if none found.
func (m *UpdateLeaveTypeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateLeaveTypeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for IsPaid

	// no validation rules for RequiresApproval

	// no validation rules for RequiresProof

	// no validation rules for DeductQuota

	// no validation rules for Unit

	// no validation rules for MinDuration

	// no validation rules for MaxDuration

	// no validation rules for AdvanceDays

	if all {
		switch v := interface{}(m.GetApprovalRules()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateLeaveTypeRequestValidationError{
					field:  "ApprovalRules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateLeaveTypeRequestValidationError{
					field:  "ApprovalRules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApprovalRules()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateLeaveTypeRequestValidationError{
				field:  "ApprovalRules",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Color

	// no validation rules for IsActive

	// no validation rules for Sort

	if len(errors) > 0 {
		return UpdateLeaveTypeRequestMultiError(errors)
	}

	return nil
}

// UpdateLeaveTypeRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateLeaveTypeRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateLeaveTypeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateLeaveTypeRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateLeaveTypeRequestMultiError) AllErrors() []error { return m }

// UpdateLeaveTypeRequestValidationError is the validation error returned by
// UpdateLeaveTypeRequest.Validate if the designated constraints aren't met.
type UpdateLeaveTypeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateLeaveTypeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateLeaveTypeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateLeaveTypeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateLeaveTypeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateLeaveTypeRequestValidationError) ErrorName() string {
	return "UpdateLeaveTypeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateLeaveTypeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateLeaveTypeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateLeaveTypeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateLeaveTypeRequestValidationError{}

// Validate checks the field values on DeleteLeaveTypeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteLeaveTypeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteLeaveTypeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteLeaveTypeRequestMultiError, or nil if none found.
func (m *DeleteLeaveTypeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteLeaveTypeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteLeaveTypeRequestMultiError(errors)
	}

	return nil
}

// DeleteLeaveTypeRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteLeaveTypeRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteLeaveTypeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteLeaveTypeRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteLeaveTypeRequestMultiError) AllErrors() []error { return m }

// DeleteLeaveTypeRequestValidationError is the validation error returned by
// DeleteLeaveTypeRequest.Validate if the designated constraints aren't met.
type DeleteLeaveTypeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteLeaveTypeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteLeaveTypeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteLeaveTypeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteLeaveTypeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteLeaveTypeRequestValidationError) ErrorName() string {
	return "DeleteLeaveTypeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteLeaveTypeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteLeaveTypeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteLeaveTypeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteLeaveTypeRequestValidationError{}

// Validate checks the field values on DeleteLeaveTypeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteLeaveTypeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteLeaveTypeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteLeaveTypeResponseMultiError, or nil if none found.
func (m *DeleteLeaveTypeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteLeaveTypeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	if len(errors) > 0 {
		return DeleteLeaveTypeResponseMultiError(errors)
	}

	return nil
}

// DeleteLeaveTypeResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteLeaveTypeResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteLeaveTypeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteLeaveTypeResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteLeaveTypeResponseMultiError) AllErrors() []error { return m }

// DeleteLeaveTypeResponseValidationError is the validation error returned by
// DeleteLeaveTypeResponse.Validate if the designated constraints aren't met.
type DeleteLeaveTypeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteLeaveTypeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteLeaveTypeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteLeaveTypeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteLeaveTypeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteLeaveTypeResponseValidationError) ErrorName() string {
	return "DeleteLeaveTypeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteLeaveTypeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteLeaveTypeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteLeaveTypeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteLeaveTypeResponseValidationError{}

// Validate checks the field values on GetLeaveTypeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetLeaveTypeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLeaveTypeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLeaveTypeRequestMultiError, or nil if none found.
func (m *GetLeaveTypeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLeaveTypeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetLeaveTypeRequestMultiError(errors)
	}

	return nil
}

// GetLeaveTypeRequestMultiError is an error wrapping multiple validation
// errors returned by GetLeaveTypeRequest.ValidateAll() if the designated
// constraints aren't met.
type GetLeaveTypeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLeaveTypeRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLeaveTypeRequestMultiError) AllErrors() []error { return m }

// GetLeaveTypeRequestValidationError is the validation error returned by
// GetLeaveTypeRequest.Validate if the designated constraints aren't met.
type GetLeaveTypeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLeaveTypeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLeaveTypeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLeaveTypeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLeaveTypeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLeaveTypeRequestValidationError) ErrorName() string {
	return "GetLeaveTypeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetLeaveTypeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLeaveTypeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLeaveTypeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLeaveTypeRequestValidationError{}

// Validate checks the field values on ListLeaveTypesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListLeaveTypesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListLeaveTypesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListLeaveTypesRequestMultiError, or nil if none found.
func (m *ListLeaveTypesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListLeaveTypesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TenantId

	// no validation rules for IsActive

	// no validation rules for RequiresProof

	// no validation rules for DeductQuota

	// no validation rules for Keyword

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListLeaveTypesRequestMultiError(errors)
	}

	return nil
}

// ListLeaveTypesRequestMultiError is an error wrapping multiple validation
// errors returned by ListLeaveTypesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListLeaveTypesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListLeaveTypesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListLeaveTypesRequestMultiError) AllErrors() []error { return m }

// ListLeaveTypesRequestValidationError is the validation error returned by
// ListLeaveTypesRequest.Validate if the designated constraints aren't met.
type ListLeaveTypesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListLeaveTypesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListLeaveTypesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListLeaveTypesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListLeaveTypesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListLeaveTypesRequestValidationError) ErrorName() string {
	return "ListLeaveTypesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListLeaveTypesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListLeaveTypesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListLeaveTypesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListLeaveTypesRequestValidationError{}

// Validate checks the field values on ListLeaveTypesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListLeaveTypesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListLeaveTypesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListLeaveTypesResponseMultiError, or nil if none found.
func (m *ListLeaveTypesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListLeaveTypesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListLeaveTypesResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListLeaveTypesResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListLeaveTypesResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListLeaveTypesResponseMultiError(errors)
	}

	return nil
}

// ListLeaveTypesResponseMultiError is an error wrapping multiple validation
// errors returned by ListLeaveTypesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListLeaveTypesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListLeaveTypesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListLeaveTypesResponseMultiError) AllErrors() []error { return m }

// ListLeaveTypesResponseValidationError is the validation error returned by
// ListLeaveTypesResponse.Validate if the designated constraints aren't met.
type ListLeaveTypesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListLeaveTypesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListLeaveTypesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListLeaveTypesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListLeaveTypesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListLeaveTypesResponseValidationError) ErrorName() string {
	return "ListLeaveTypesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListLeaveTypesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListLeaveTypesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListLeaveTypesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListLeaveTypesResponseValidationError{}

// Validate checks the field values on ListActiveLeaveTypesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListActiveLeaveTypesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListActiveLeaveTypesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListActiveLeaveTypesRequestMultiError, or nil if none found.
func (m *ListActiveLeaveTypesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListActiveLeaveTypesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TenantId

	if len(errors) > 0 {
		return ListActiveLeaveTypesRequestMultiError(errors)
	}

	return nil
}

// ListActiveLeaveTypesRequestMultiError is an error wrapping multiple
// validation errors returned by ListActiveLeaveTypesRequest.ValidateAll() if
// the designated constraints aren't met.
type ListActiveLeaveTypesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListActiveLeaveTypesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListActiveLeaveTypesRequestMultiError) AllErrors() []error { return m }

// ListActiveLeaveTypesRequestValidationError is the validation error returned
// by ListActiveLeaveTypesRequest.Validate if the designated constraints
// aren't met.
type ListActiveLeaveTypesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListActiveLeaveTypesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListActiveLeaveTypesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListActiveLeaveTypesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListActiveLeaveTypesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListActiveLeaveTypesRequestValidationError) ErrorName() string {
	return "ListActiveLeaveTypesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListActiveLeaveTypesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListActiveLeaveTypesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListActiveLeaveTypesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListActiveLeaveTypesRequestValidationError{}

// Validate checks the field values on ListActiveLeaveTypesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListActiveLeaveTypesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListActiveLeaveTypesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListActiveLeaveTypesResponseMultiError, or nil if none found.
func (m *ListActiveLeaveTypesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListActiveLeaveTypesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListActiveLeaveTypesResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListActiveLeaveTypesResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListActiveLeaveTypesResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListActiveLeaveTypesResponseMultiError(errors)
	}

	return nil
}

// ListActiveLeaveTypesResponseMultiError is an error wrapping multiple
// validation errors returned by ListActiveLeaveTypesResponse.ValidateAll() if
// the designated constraints aren't met.
type ListActiveLeaveTypesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListActiveLeaveTypesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListActiveLeaveTypesResponseMultiError) AllErrors() []error { return m }

// ListActiveLeaveTypesResponseValidationError is the validation error returned
// by ListActiveLeaveTypesResponse.Validate if the designated constraints
// aren't met.
type ListActiveLeaveTypesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListActiveLeaveTypesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListActiveLeaveTypesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListActiveLeaveTypesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListActiveLeaveTypesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListActiveLeaveTypesResponseValidationError) ErrorName() string {
	return "ListActiveLeaveTypesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListActiveLeaveTypesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListActiveLeaveTypesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListActiveLeaveTypesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListActiveLeaveTypesResponseValidationError{}

// Validate checks the field values on CreateLeaveRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateLeaveRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateLeaveRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateLeaveRequestRequestMultiError, or nil if none found.
func (m *CreateLeaveRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLeaveRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TenantId

	// no validation rules for EmployeeId

	// no validation rules for EmployeeName

	// no validation rules for DepartmentId

	// no validation rules for LeaveTypeId

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateLeaveRequestRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateLeaveRequestRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateLeaveRequestRequestValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateLeaveRequestRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateLeaveRequestRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateLeaveRequestRequestValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Duration

	// no validation rules for Reason

	if len(errors) > 0 {
		return CreateLeaveRequestRequestMultiError(errors)
	}

	return nil
}

// CreateLeaveRequestRequestMultiError is an error wrapping multiple validation
// errors returned by CreateLeaveRequestRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateLeaveRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLeaveRequestRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLeaveRequestRequestMultiError) AllErrors() []error { return m }

// CreateLeaveRequestRequestValidationError is the validation error returned by
// CreateLeaveRequestRequest.Validate if the designated constraints aren't met.
type CreateLeaveRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLeaveRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLeaveRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLeaveRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLeaveRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLeaveRequestRequestValidationError) ErrorName() string {
	return "CreateLeaveRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLeaveRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLeaveRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLeaveRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLeaveRequestRequestValidationError{}

// Validate checks the field values on UpdateLeaveRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateLeaveRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateLeaveRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateLeaveRequestRequestMultiError, or nil if none found.
func (m *UpdateLeaveRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateLeaveRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateLeaveRequestRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateLeaveRequestRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateLeaveRequestRequestValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateLeaveRequestRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateLeaveRequestRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateLeaveRequestRequestValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Duration

	// no validation rules for Reason

	if len(errors) > 0 {
		return UpdateLeaveRequestRequestMultiError(errors)
	}

	return nil
}

// UpdateLeaveRequestRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateLeaveRequestRequest.ValidateAll() if the
// designated constraints aren't met.
type UpdateLeaveRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateLeaveRequestRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateLeaveRequestRequestMultiError) AllErrors() []error { return m }

// UpdateLeaveRequestRequestValidationError is the validation error returned by
// UpdateLeaveRequestRequest.Validate if the designated constraints aren't met.
type UpdateLeaveRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateLeaveRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateLeaveRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateLeaveRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateLeaveRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateLeaveRequestRequestValidationError) ErrorName() string {
	return "UpdateLeaveRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateLeaveRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateLeaveRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateLeaveRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateLeaveRequestRequestValidationError{}

// Validate checks the field values on SubmitLeaveRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubmitLeaveRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmitLeaveRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubmitLeaveRequestRequestMultiError, or nil if none found.
func (m *SubmitLeaveRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmitLeaveRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	// no validation rules for SubmitterId

	if len(errors) > 0 {
		return SubmitLeaveRequestRequestMultiError(errors)
	}

	return nil
}

// SubmitLeaveRequestRequestMultiError is an error wrapping multiple validation
// errors returned by SubmitLeaveRequestRequest.ValidateAll() if the
// designated constraints aren't met.
type SubmitLeaveRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmitLeaveRequestRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmitLeaveRequestRequestMultiError) AllErrors() []error { return m }

// SubmitLeaveRequestRequestValidationError is the validation error returned by
// SubmitLeaveRequestRequest.Validate if the designated constraints aren't met.
type SubmitLeaveRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitLeaveRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitLeaveRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitLeaveRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitLeaveRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitLeaveRequestRequestValidationError) ErrorName() string {
	return "SubmitLeaveRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SubmitLeaveRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitLeaveRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitLeaveRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitLeaveRequestRequestValidationError{}

// Validate checks the field values on SubmitLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubmitLeaveRequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmitLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubmitLeaveRequestResponseMultiError, or nil if none found.
func (m *SubmitLeaveRequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmitLeaveRequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if len(errors) > 0 {
		return SubmitLeaveRequestResponseMultiError(errors)
	}

	return nil
}

// SubmitLeaveRequestResponseMultiError is an error wrapping multiple
// validation errors returned by SubmitLeaveRequestResponse.ValidateAll() if
// the designated constraints aren't met.
type SubmitLeaveRequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmitLeaveRequestResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmitLeaveRequestResponseMultiError) AllErrors() []error { return m }

// SubmitLeaveRequestResponseValidationError is the validation error returned
// by SubmitLeaveRequestResponse.Validate if the designated constraints aren't met.
type SubmitLeaveRequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitLeaveRequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitLeaveRequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitLeaveRequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitLeaveRequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitLeaveRequestResponseValidationError) ErrorName() string {
	return "SubmitLeaveRequestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SubmitLeaveRequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitLeaveRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitLeaveRequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitLeaveRequestResponseValidationError{}

// Validate checks the field values on WithdrawLeaveRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WithdrawLeaveRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WithdrawLeaveRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WithdrawLeaveRequestRequestMultiError, or nil if none found.
func (m *WithdrawLeaveRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WithdrawLeaveRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	// no validation rules for OperatorId

	if len(errors) > 0 {
		return WithdrawLeaveRequestRequestMultiError(errors)
	}

	return nil
}

// WithdrawLeaveRequestRequestMultiError is an error wrapping multiple
// validation errors returned by WithdrawLeaveRequestRequest.ValidateAll() if
// the designated constraints aren't met.
type WithdrawLeaveRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WithdrawLeaveRequestRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WithdrawLeaveRequestRequestMultiError) AllErrors() []error { return m }

// WithdrawLeaveRequestRequestValidationError is the validation error returned
// by WithdrawLeaveRequestRequest.Validate if the designated constraints
// aren't met.
type WithdrawLeaveRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WithdrawLeaveRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WithdrawLeaveRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WithdrawLeaveRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WithdrawLeaveRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WithdrawLeaveRequestRequestValidationError) ErrorName() string {
	return "WithdrawLeaveRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WithdrawLeaveRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWithdrawLeaveRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WithdrawLeaveRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WithdrawLeaveRequestRequestValidationError{}

// Validate checks the field values on WithdrawLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WithdrawLeaveRequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WithdrawLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WithdrawLeaveRequestResponseMultiError, or nil if none found.
func (m *WithdrawLeaveRequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *WithdrawLeaveRequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	if len(errors) > 0 {
		return WithdrawLeaveRequestResponseMultiError(errors)
	}

	return nil
}

// WithdrawLeaveRequestResponseMultiError is an error wrapping multiple
// validation errors returned by WithdrawLeaveRequestResponse.ValidateAll() if
// the designated constraints aren't met.
type WithdrawLeaveRequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WithdrawLeaveRequestResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WithdrawLeaveRequestResponseMultiError) AllErrors() []error { return m }

// WithdrawLeaveRequestResponseValidationError is the validation error returned
// by WithdrawLeaveRequestResponse.Validate if the designated constraints
// aren't met.
type WithdrawLeaveRequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WithdrawLeaveRequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WithdrawLeaveRequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WithdrawLeaveRequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WithdrawLeaveRequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WithdrawLeaveRequestResponseValidationError) ErrorName() string {
	return "WithdrawLeaveRequestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e WithdrawLeaveRequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWithdrawLeaveRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WithdrawLeaveRequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WithdrawLeaveRequestResponseValidationError{}

// Validate checks the field values on CancelLeaveRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CancelLeaveRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelLeaveRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelLeaveRequestRequestMultiError, or nil if none found.
func (m *CancelLeaveRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelLeaveRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	// no validation rules for OperatorId

	// no validation rules for Reason

	if len(errors) > 0 {
		return CancelLeaveRequestRequestMultiError(errors)
	}

	return nil
}

// CancelLeaveRequestRequestMultiError is an error wrapping multiple validation
// errors returned by CancelLeaveRequestRequest.ValidateAll() if the
// designated constraints aren't met.
type CancelLeaveRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelLeaveRequestRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelLeaveRequestRequestMultiError) AllErrors() []error { return m }

// CancelLeaveRequestRequestValidationError is the validation error returned by
// CancelLeaveRequestRequest.Validate if the designated constraints aren't met.
type CancelLeaveRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelLeaveRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelLeaveRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelLeaveRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelLeaveRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelLeaveRequestRequestValidationError) ErrorName() string {
	return "CancelLeaveRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CancelLeaveRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelLeaveRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelLeaveRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelLeaveRequestRequestValidationError{}

// Validate checks the field values on CancelLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CancelLeaveRequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelLeaveRequestResponseMultiError, or nil if none found.
func (m *CancelLeaveRequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelLeaveRequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	if len(errors) > 0 {
		return CancelLeaveRequestResponseMultiError(errors)
	}

	return nil
}

// CancelLeaveRequestResponseMultiError is an error wrapping multiple
// validation errors returned by CancelLeaveRequestResponse.ValidateAll() if
// the designated constraints aren't met.
type CancelLeaveRequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelLeaveRequestResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelLeaveRequestResponseMultiError) AllErrors() []error { return m }

// CancelLeaveRequestResponseValidationError is the validation error returned
// by CancelLeaveRequestResponse.Validate if the designated constraints aren't met.
type CancelLeaveRequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelLeaveRequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelLeaveRequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelLeaveRequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelLeaveRequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelLeaveRequestResponseValidationError) ErrorName() string {
	return "CancelLeaveRequestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CancelLeaveRequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelLeaveRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelLeaveRequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelLeaveRequestResponseValidationError{}

// Validate checks the field values on GetLeaveRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetLeaveRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLeaveRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLeaveRequestRequestMultiError, or nil if none found.
func (m *GetLeaveRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLeaveRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	if len(errors) > 0 {
		return GetLeaveRequestRequestMultiError(errors)
	}

	return nil
}

// GetLeaveRequestRequestMultiError is an error wrapping multiple validation
// errors returned by GetLeaveRequestRequest.ValidateAll() if the designated
// constraints aren't met.
type GetLeaveRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLeaveRequestRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLeaveRequestRequestMultiError) AllErrors() []error { return m }

// GetLeaveRequestRequestValidationError is the validation error returned by
// GetLeaveRequestRequest.Validate if the designated constraints aren't met.
type GetLeaveRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLeaveRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLeaveRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLeaveRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLeaveRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLeaveRequestRequestValidationError) ErrorName() string {
	return "GetLeaveRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetLeaveRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLeaveRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLeaveRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLeaveRequestRequestValidationError{}

// Validate checks the field values on ListMyLeaveRequestsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMyLeaveRequestsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMyLeaveRequestsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMyLeaveRequestsRequestMultiError, or nil if none found.
func (m *ListMyLeaveRequestsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMyLeaveRequestsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TenantId

	// no validation rules for EmployeeId

	// no validation rules for LeaveTypeId

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListMyLeaveRequestsRequestValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListMyLeaveRequestsRequestValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListMyLeaveRequestsRequestValidationError{
				field:  "StartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListMyLeaveRequestsRequestValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListMyLeaveRequestsRequestValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListMyLeaveRequestsRequestValidationError{
				field:  "EndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListMyLeaveRequestsRequestMultiError(errors)
	}

	return nil
}

// ListMyLeaveRequestsRequestMultiError is an error wrapping multiple
// validation errors returned by ListMyLeaveRequestsRequest.ValidateAll() if
// the designated constraints aren't met.
type ListMyLeaveRequestsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMyLeaveRequestsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMyLeaveRequestsRequestMultiError) AllErrors() []error { return m }

// ListMyLeaveRequestsRequestValidationError is the validation error returned
// by ListMyLeaveRequestsRequest.Validate if the designated constraints aren't met.
type ListMyLeaveRequestsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMyLeaveRequestsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMyLeaveRequestsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMyLeaveRequestsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMyLeaveRequestsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMyLeaveRequestsRequestValidationError) ErrorName() string {
	return "ListMyLeaveRequestsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListMyLeaveRequestsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMyLeaveRequestsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMyLeaveRequestsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMyLeaveRequestsRequestValidationError{}

// Validate checks the field values on ListLeaveRequestsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListLeaveRequestsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListLeaveRequestsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListLeaveRequestsRequestMultiError, or nil if none found.
func (m *ListLeaveRequestsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListLeaveRequestsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TenantId

	// no validation rules for LeaveTypeId

	// no validation rules for DepartmentId

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListLeaveRequestsRequestValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListLeaveRequestsRequestValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListLeaveRequestsRequestValidationError{
				field:  "StartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListLeaveRequestsRequestValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListLeaveRequestsRequestValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListLeaveRequestsRequestValidationError{
				field:  "EndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Keyword

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListLeaveRequestsRequestMultiError(errors)
	}

	return nil
}

// ListLeaveRequestsRequestMultiError is an error wrapping multiple validation
// errors returned by ListLeaveRequestsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListLeaveRequestsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListLeaveRequestsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListLeaveRequestsRequestMultiError) AllErrors() []error { return m }

// ListLeaveRequestsRequestValidationError is the validation error returned by
// ListLeaveRequestsRequest.Validate if the designated constraints aren't met.
type ListLeaveRequestsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListLeaveRequestsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListLeaveRequestsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListLeaveRequestsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListLeaveRequestsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListLeaveRequestsRequestValidationError) ErrorName() string {
	return "ListLeaveRequestsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListLeaveRequestsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListLeaveRequestsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListLeaveRequestsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListLeaveRequestsRequestValidationError{}

// Validate checks the field values on ListLeaveRequestsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListLeaveRequestsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListLeaveRequestsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListLeaveRequestsResponseMultiError, or nil if none found.
func (m *ListLeaveRequestsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListLeaveRequestsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListLeaveRequestsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListLeaveRequestsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListLeaveRequestsResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListLeaveRequestsResponseMultiError(errors)
	}

	return nil
}

// ListLeaveRequestsResponseMultiError is an error wrapping multiple validation
// errors returned by ListLeaveRequestsResponse.ValidateAll() if the
// designated constraints aren't met.
type ListLeaveRequestsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListLeaveRequestsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListLeaveRequestsResponseMultiError) AllErrors() []error { return m }

// ListLeaveRequestsResponseValidationError is the validation error returned by
// ListLeaveRequestsResponse.Validate if the designated constraints aren't met.
type ListLeaveRequestsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListLeaveRequestsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListLeaveRequestsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListLeaveRequestsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListLeaveRequestsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListLeaveRequestsResponseValidationError) ErrorName() string {
	return "ListLeaveRequestsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListLeaveRequestsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListLeaveRequestsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListLeaveRequestsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListLeaveRequestsResponseValidationError{}

// Validate checks the field values on ListPendingApprovalsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPendingApprovalsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPendingApprovalsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPendingApprovalsRequestMultiError, or nil if none found.
func (m *ListPendingApprovalsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPendingApprovalsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TenantId

	// no validation rules for ApproverId

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListPendingApprovalsRequestMultiError(errors)
	}

	return nil
}

// ListPendingApprovalsRequestMultiError is an error wrapping multiple
// validation errors returned by ListPendingApprovalsRequest.ValidateAll() if
// the designated constraints aren't met.
type ListPendingApprovalsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPendingApprovalsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPendingApprovalsRequestMultiError) AllErrors() []error { return m }

// ListPendingApprovalsRequestValidationError is the validation error returned
// by ListPendingApprovalsRequest.Validate if the designated constraints
// aren't met.
type ListPendingApprovalsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPendingApprovalsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPendingApprovalsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPendingApprovalsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPendingApprovalsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPendingApprovalsRequestValidationError) ErrorName() string {
	return "ListPendingApprovalsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListPendingApprovalsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPendingApprovalsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPendingApprovalsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPendingApprovalsRequestValidationError{}

// Validate checks the field values on ApproveLeaveRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApproveLeaveRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApproveLeaveRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApproveLeaveRequestRequestMultiError, or nil if none found.
func (m *ApproveLeaveRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ApproveLeaveRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	// no validation rules for ApproverId

	// no validation rules for Comment

	if len(errors) > 0 {
		return ApproveLeaveRequestRequestMultiError(errors)
	}

	return nil
}

// ApproveLeaveRequestRequestMultiError is an error wrapping multiple
// validation errors returned by ApproveLeaveRequestRequest.ValidateAll() if
// the designated constraints aren't met.
type ApproveLeaveRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApproveLeaveRequestRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApproveLeaveRequestRequestMultiError) AllErrors() []error { return m }

// ApproveLeaveRequestRequestValidationError is the validation error returned
// by ApproveLeaveRequestRequest.Validate if the designated constraints aren't met.
type ApproveLeaveRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApproveLeaveRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApproveLeaveRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApproveLeaveRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApproveLeaveRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApproveLeaveRequestRequestValidationError) ErrorName() string {
	return "ApproveLeaveRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ApproveLeaveRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApproveLeaveRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApproveLeaveRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApproveLeaveRequestRequestValidationError{}

// Validate checks the field values on ApproveLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApproveLeaveRequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApproveLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApproveLeaveRequestResponseMultiError, or nil if none found.
func (m *ApproveLeaveRequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ApproveLeaveRequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if len(errors) > 0 {
		return ApproveLeaveRequestResponseMultiError(errors)
	}

	return nil
}

// ApproveLeaveRequestResponseMultiError is an error wrapping multiple
// validation errors returned by ApproveLeaveRequestResponse.ValidateAll() if
// the designated constraints aren't met.
type ApproveLeaveRequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApproveLeaveRequestResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApproveLeaveRequestResponseMultiError) AllErrors() []error { return m }

// ApproveLeaveRequestResponseValidationError is the validation error returned
// by ApproveLeaveRequestResponse.Validate if the designated constraints
// aren't met.
type ApproveLeaveRequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApproveLeaveRequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApproveLeaveRequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApproveLeaveRequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApproveLeaveRequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApproveLeaveRequestResponseValidationError) ErrorName() string {
	return "ApproveLeaveRequestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ApproveLeaveRequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApproveLeaveRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApproveLeaveRequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApproveLeaveRequestResponseValidationError{}

// Validate checks the field values on RejectLeaveRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RejectLeaveRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RejectLeaveRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RejectLeaveRequestRequestMultiError, or nil if none found.
func (m *RejectLeaveRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RejectLeaveRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	// no validation rules for ApproverId

	// no validation rules for Comment

	if len(errors) > 0 {
		return RejectLeaveRequestRequestMultiError(errors)
	}

	return nil
}

// RejectLeaveRequestRequestMultiError is an error wrapping multiple validation
// errors returned by RejectLeaveRequestRequest.ValidateAll() if the
// designated constraints aren't met.
type RejectLeaveRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RejectLeaveRequestRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RejectLeaveRequestRequestMultiError) AllErrors() []error { return m }

// RejectLeaveRequestRequestValidationError is the validation error returned by
// RejectLeaveRequestRequest.Validate if the designated constraints aren't met.
type RejectLeaveRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RejectLeaveRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RejectLeaveRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RejectLeaveRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RejectLeaveRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RejectLeaveRequestRequestValidationError) ErrorName() string {
	return "RejectLeaveRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RejectLeaveRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRejectLeaveRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RejectLeaveRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RejectLeaveRequestRequestValidationError{}

// Validate checks the field values on RejectLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RejectLeaveRequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RejectLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RejectLeaveRequestResponseMultiError, or nil if none found.
func (m *RejectLeaveRequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RejectLeaveRequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if len(errors) > 0 {
		return RejectLeaveRequestResponseMultiError(errors)
	}

	return nil
}

// RejectLeaveRequestResponseMultiError is an error wrapping multiple
// validation errors returned by RejectLeaveRequestResponse.ValidateAll() if
// the designated constraints aren't met.
type RejectLeaveRequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RejectLeaveRequestResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RejectLeaveRequestResponseMultiError) AllErrors() []error { return m }

// RejectLeaveRequestResponseValidationError is the validation error returned
// by RejectLeaveRequestResponse.Validate if the designated constraints aren't met.
type RejectLeaveRequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RejectLeaveRequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RejectLeaveRequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RejectLeaveRequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RejectLeaveRequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RejectLeaveRequestResponseValidationError) ErrorName() string {
	return "RejectLeaveRequestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RejectLeaveRequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRejectLeaveRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RejectLeaveRequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RejectLeaveRequestResponseValidationError{}

// Validate checks the field values on InitEmployeeQuotaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitEmployeeQuotaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitEmployeeQuotaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitEmployeeQuotaRequestMultiError, or nil if none found.
func (m *InitEmployeeQuotaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InitEmployeeQuotaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TenantId

	// no validation rules for EmployeeId

	// no validation rules for Year

	if len(errors) > 0 {
		return InitEmployeeQuotaRequestMultiError(errors)
	}

	return nil
}

// InitEmployeeQuotaRequestMultiError is an error wrapping multiple validation
// errors returned by InitEmployeeQuotaRequest.ValidateAll() if the designated
// constraints aren't met.
type InitEmployeeQuotaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitEmployeeQuotaRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitEmployeeQuotaRequestMultiError) AllErrors() []error { return m }

// InitEmployeeQuotaRequestValidationError is the validation error returned by
// InitEmployeeQuotaRequest.Validate if the designated constraints aren't met.
type InitEmployeeQuotaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitEmployeeQuotaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitEmployeeQuotaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitEmployeeQuotaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitEmployeeQuotaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitEmployeeQuotaRequestValidationError) ErrorName() string {
	return "InitEmployeeQuotaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InitEmployeeQuotaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitEmployeeQuotaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitEmployeeQuotaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitEmployeeQuotaRequestValidationError{}

// Validate checks the field values on InitEmployeeQuotaResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitEmployeeQuotaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitEmployeeQuotaResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitEmployeeQuotaResponseMultiError, or nil if none found.
func (m *InitEmployeeQuotaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InitEmployeeQuotaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	if len(errors) > 0 {
		return InitEmployeeQuotaResponseMultiError(errors)
	}

	return nil
}

// InitEmployeeQuotaResponseMultiError is an error wrapping multiple validation
// errors returned by InitEmployeeQuotaResponse.ValidateAll() if the
// designated constraints aren't met.
type InitEmployeeQuotaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitEmployeeQuotaResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitEmployeeQuotaResponseMultiError) AllErrors() []error { return m }

// InitEmployeeQuotaResponseValidationError is the validation error returned by
// InitEmployeeQuotaResponse.Validate if the designated constraints aren't met.
type InitEmployeeQuotaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitEmployeeQuotaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitEmployeeQuotaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitEmployeeQuotaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitEmployeeQuotaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitEmployeeQuotaResponseValidationError) ErrorName() string {
	return "InitEmployeeQuotaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InitEmployeeQuotaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitEmployeeQuotaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitEmployeeQuotaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitEmployeeQuotaResponseValidationError{}

// Validate checks the field values on UpdateQuotaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateQuotaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateQuotaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateQuotaRequestMultiError, or nil if none found.
func (m *UpdateQuotaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateQuotaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TotalQuota

	if len(errors) > 0 {
		return UpdateQuotaRequestMultiError(errors)
	}

	return nil
}

// UpdateQuotaRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateQuotaRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateQuotaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateQuotaRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateQuotaRequestMultiError) AllErrors() []error { return m }

// UpdateQuotaRequestValidationError is the validation error returned by
// UpdateQuotaRequest.Validate if the designated constraints aren't met.
type UpdateQuotaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateQuotaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateQuotaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateQuotaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateQuotaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateQuotaRequestValidationError) ErrorName() string {
	return "UpdateQuotaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateQuotaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateQuotaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateQuotaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateQuotaRequestValidationError{}

// Validate checks the field values on GetEmployeeQuotasRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetEmployeeQuotasRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetEmployeeQuotasRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetEmployeeQuotasRequestMultiError, or nil if none found.
func (m *GetEmployeeQuotasRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetEmployeeQuotasRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TenantId

	// no validation rules for EmployeeId

	// no validation rules for Year

	if len(errors) > 0 {
		return GetEmployeeQuotasRequestMultiError(errors)
	}

	return nil
}

// GetEmployeeQuotasRequestMultiError is an error wrapping multiple validation
// errors returned by GetEmployeeQuotasRequest.ValidateAll() if the designated
// constraints aren't met.
type GetEmployeeQuotasRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetEmployeeQuotasRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetEmployeeQuotasRequestMultiError) AllErrors() []error { return m }

// GetEmployeeQuotasRequestValidationError is the validation error returned by
// GetEmployeeQuotasRequest.Validate if the designated constraints aren't met.
type GetEmployeeQuotasRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetEmployeeQuotasRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetEmployeeQuotasRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetEmployeeQuotasRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetEmployeeQuotasRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetEmployeeQuotasRequestValidationError) ErrorName() string {
	return "GetEmployeeQuotasRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetEmployeeQuotasRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetEmployeeQuotasRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetEmployeeQuotasRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetEmployeeQuotasRequestValidationError{}

// Validate checks the field values on GetEmployeeQuotasResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetEmployeeQuotasResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetEmployeeQuotasResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetEmployeeQuotasResponseMultiError, or nil if none found.
func (m *GetEmployeeQuotasResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetEmployeeQuotasResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetEmployeeQuotasResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetEmployeeQuotasResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetEmployeeQuotasResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetEmployeeQuotasResponseMultiError(errors)
	}

	return nil
}

// GetEmployeeQuotasResponseMultiError is an error wrapping multiple validation
// errors returned by GetEmployeeQuotasResponse.ValidateAll() if the
// designated constraints aren't met.
type GetEmployeeQuotasResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetEmployeeQuotasResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetEmployeeQuotasResponseMultiError) AllErrors() []error { return m }

// GetEmployeeQuotasResponseValidationError is the validation error returned by
// GetEmployeeQuotasResponse.Validate if the designated constraints aren't met.
type GetEmployeeQuotasResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetEmployeeQuotasResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetEmployeeQuotasResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetEmployeeQuotasResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetEmployeeQuotasResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetEmployeeQuotasResponseValidationError) ErrorName() string {
	return "GetEmployeeQuotasResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetEmployeeQuotasResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetEmployeeQuotasResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetEmployeeQuotasResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetEmployeeQuotasResponseValidationError{}
